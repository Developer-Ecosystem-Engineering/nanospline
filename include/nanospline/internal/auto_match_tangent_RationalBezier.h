/**
 * This code is automatically generated by scripts/optimal_turning_angle.py
 */

#pragma once
#include <cassert>
#include <vector>

#include <nanospline/Exceptions.h>
#include <nanospline/PolynomialRootFinder.h>
#include <nanospline/BezierBase.h>

namespace nanospline {
namespace internal {


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_2(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2,
        Scalar w0, Scalar w1, Scalar w2,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 1>::find_real_roots_in_interval({
        -2*cx0*tcutxp + 2*cx1*tcutxp - 2*cy0*tcutyp + 2*cy1*tcutyp,
    2*cx0*tcutxp - 4*cx1*tcutxp + 2*cx2*tcutxp + 2*cy0*tcutyp - 4*cy1*tcutyp + 2*cy2*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_3(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3,
        Scalar w0, Scalar w1, Scalar w2, Scalar w3,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 2>::find_real_roots_in_interval({
        -3*cx0*tcutxp + 3*cx1*tcutxp - 3*cy0*tcutyp + 3*cy1*tcutyp,
    6*cx0*tcutxp - 12*cx1*tcutxp + 6*cx2*tcutxp + 6*cy0*tcutyp - 12*cy1*tcutyp + 6*cy2*tcutyp,
    -3*cx0*tcutxp + 9*cx1*tcutxp - 9*cx2*tcutxp + 3*cx3*tcutxp - 3*cy0*tcutyp + 9*cy1*tcutyp - 9*cy2*tcutyp + 3*cy3*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_4(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3, Scalar cx4, Scalar cy4,
        Scalar w0, Scalar w1, Scalar w2, Scalar w3, Scalar w4,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 3>::find_real_roots_in_interval({
        -4*cx0*tcutxp + 4*cx1*tcutxp - 4*cy0*tcutyp + 4*cy1*tcutyp,
    12*cx0*tcutxp - 24*cx1*tcutxp + 12*cx2*tcutxp + 12*cy0*tcutyp - 24*cy1*tcutyp + 12*cy2*tcutyp,
    -12*cx0*tcutxp + 36*cx1*tcutxp - 36*cx2*tcutxp + 12*cx3*tcutxp - 12*cy0*tcutyp + 36*cy1*tcutyp - 36*cy2*tcutyp + 12*cy3*tcutyp,
    4*cx0*tcutxp - 16*cx1*tcutxp + 24*cx2*tcutxp - 16*cx3*tcutxp + 4*cx4*tcutxp + 4*cy0*tcutyp - 16*cy1*tcutyp + 24*cy2*tcutyp - 16*cy3*tcutyp + 4*cy4*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar, typename Derived, typename Derived2>
std::vector<Scalar> match_tangent_rational_bezier(
        const Eigen::PlainObjectBase<Derived>& ctrl_pts,
        const Eigen::PlainObjectBase<Derived2>& weights,
        const int degree,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0, Scalar t1 = 1) {
    switch(degree) {
        case 2:
            return match_tangent_RationalBezier_degree_2(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), weights(0), weights(1), weights(2), tangent, t0, t1);
        case 3:
            return match_tangent_RationalBezier_degree_3(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), weights(0), weights(1), weights(2), weights(3), tangent, t0, t1);
        case 4:
            return match_tangent_RationalBezier_degree_4(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), ctrl_pts(4,0), ctrl_pts(4,1), weights(0), weights(1), weights(2), weights(3), weights(4), tangent, t0, t1);
        default:
            throw not_implemented_error(
                "Turning angle reduction only works on RationalBezier curve with degree lower than 4");
    }
}



} // End internal namespace
} // End nanospline namespace

