/**
 * This code is automatically generated by scripts/optimal_turning_angle.py
 */

#pragma once
#include <cassert>
#include <vector>

#include <nanospline/Exceptions.h>
#include <nanospline/PolynomialRootFinder.h>
#include <nanospline/BezierBase.h>

namespace nanospline {
namespace internal {


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_2(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2,
        Scalar w0, Scalar w1, Scalar w2,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = 1e-8;

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 1>::find_real_roots_in_interval({
        -2*cx0*tcutxp + 2*cx1*tcutxp - 2*cy0*tcutyp + 2*cy1*tcutyp,
    2*cx0*tcutxp - 4*cx1*tcutxp + 2*cx2*tcutxp + 2*cy0*tcutyp - 4*cy1*tcutyp + 2*cy2*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_3(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3,
        Scalar w0, Scalar w1, Scalar w2, Scalar w3,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = 1e-8;

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 2>::find_real_roots_in_interval({
        -3*cx0*tcutxp + 3*cx1*tcutxp - 3*cy0*tcutyp + 3*cy1*tcutyp,
    6*cx0*tcutxp - 12*cx1*tcutxp + 6*cx2*tcutxp + 6*cy0*tcutyp - 12*cy1*tcutyp + 6*cy2*tcutyp,
    -3*cx0*tcutxp + 9*cx1*tcutxp - 9*cx2*tcutxp + 3*cx3*tcutxp - 3*cy0*tcutyp + 9*cy1*tcutyp - 9*cy2*tcutyp + 3*cy3*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> match_tangent_RationalBezier_degree_4(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3, Scalar cx4, Scalar cy4,
        Scalar w0, Scalar w1, Scalar w2, Scalar w3, Scalar w4,
        const Eigen::Matrix<Scalar, 2, 1>& tangent,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = 1e-8;

    const Scalar tcutxp = tangent[0];
    const Scalar tcutyp = tangent[1];

    PolynomialRootFinder<Scalar, 3>::find_real_roots_in_interval({
        -4*cx0*tcutxp + 4*cx1*tcutxp - 4*cy0*tcutyp + 4*cy1*tcutyp,
    12*cx0*tcutxp - 24*cx1*tcutxp + 12*cx2*tcutxp + 12*cy0*tcutyp - 24*cy1*tcutyp + 12*cy2*tcutyp,
    -12*cx0*tcutxp + 36*cx1*tcutxp - 36*cx2*tcutxp + 12*cx3*tcutxp - 12*cy0*tcutyp + 36*cy1*tcutyp - 36*cy2*tcutyp + 12*cy3*tcutyp,
    4*cx0*tcutxp - 16*cx1*tcutxp + 24*cx2*tcutxp - 16*cx3*tcutxp + 4*cx4*tcutxp + 4*cy0*tcutyp - 16*cy1*tcutyp + 24*cy2*tcutyp - 16*cy3*tcutyp + 4*cy4*tcutyp
    },
    result, t0, t1, tol);

    return result;
}


} // End internal namespace
} // End nanospline namespace

