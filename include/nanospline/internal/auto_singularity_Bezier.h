/**
 * This code is automatically generated by scripts/singularity.py
 */

#pragma once
#include <cassert>
#include <vector>

#include <nanospline/Exceptions.h>
#include <nanospline/PolynomialRootFinder.h>
#include <nanospline/BezierBase.h>

namespace nanospline {
namespace internal {


template<typename Scalar>
std::vector<Scalar> compute_Bezier_degree_2_singularities(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    PolynomialRootFinder<Scalar, 2>::find_real_roots_in_interval({
        4*cx0*cx0 - 8*cx0*cx1 + 4*cx1*cx1 + 4*cy0*cy0 - 8*cy0*cy1 + 4*cy1*cy1,
    -8*cx0*cx0 + 24*cx0*cx1 - 8*cx0*cx2 - 16*cx1*cx1 + 8*cx1*cx2 - 8*cy0*cy0 + 24*cy0*cy1 - 8*cy0*cy2 - 16*cy1*cy1 + 8*cy1*cy2,
    4*cx0*cx0 - 16*cx0*cx1 + 8*cx0*cx2 + 16*cx1*cx1 - 16*cx1*cx2 + 4*cx2*cx2 + 4*cy0*cy0 - 16*cy0*cy1 + 8*cy0*cy2 + 16*cy1*cy1 - 16*cy1*cy2 + 4*cy2*cy2
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> compute_Bezier_degree_3_singularities(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    PolynomialRootFinder<Scalar, 4>::find_real_roots_in_interval({
        9*cx0*cx0 - 18*cx0*cx1 + 9*cx1*cx1 + 9*cy0*cy0 - 18*cy0*cy1 + 9*cy1*cy1,
    -36*cx0*cx0 + 108*cx0*cx1 - 36*cx0*cx2 - 72*cx1*cx1 + 36*cx1*cx2 - 36*cy0*cy0 + 108*cy0*cy1 - 36*cy0*cy2 - 72*cy1*cy1 + 36*cy1*cy2,
    54*cx0*cx0 - 216*cx0*cx1 + 126*cx0*cx2 - 18*cx0*cx3 + 198*cx1*cx1 - 198*cx1*cx2 + 18*cx1*cx3 + 36*cx2*cx2 + 54*cy0*cy0 - 216*cy0*cy1 + 126*cy0*cy2 - 18*cy0*cy3 + 198*cy1*cy1 - 198*cy1*cy2 + 18*cy1*cy3 + 36*cy2*cy2,
    -36*cx0*cx0 + 180*cx0*cx1 - 144*cx0*cx2 + 36*cx0*cx3 - 216*cx1*cx1 + 324*cx1*cx2 - 72*cx1*cx3 - 108*cx2*cx2 + 36*cx2*cx3 - 36*cy0*cy0 + 180*cy0*cy1 - 144*cy0*cy2 + 36*cy0*cy3 - 216*cy1*cy1 + 324*cy1*cy2 - 72*cy1*cy3 - 108*cy2*cy2 + 36*cy2*cy3,
    9*cx0*cx0 - 54*cx0*cx1 + 54*cx0*cx2 - 18*cx0*cx3 + 81*cx1*cx1 - 162*cx1*cx2 + 54*cx1*cx3 + 81*cx2*cx2 - 54*cx2*cx3 + 9*cx3*cx3 + 9*cy0*cy0 - 54*cy0*cy1 + 54*cy0*cy2 - 18*cy0*cy3 + 81*cy1*cy1 - 162*cy1*cy2 + 54*cy1*cy3 + 81*cy2*cy2 - 54*cy2*cy3 + 9*cy3*cy3
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> compute_Bezier_degree_4_singularities(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3, Scalar cx4, Scalar cy4,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    PolynomialRootFinder<Scalar, 6>::find_real_roots_in_interval({
        16*cx0*cx0 - 32*cx0*cx1 + 16*cx1*cx1 + 16*cy0*cy0 - 32*cy0*cy1 + 16*cy1*cy1,
    -96*cx0*cx0 + 288*cx0*cx1 - 96*cx0*cx2 - 192*cx1*cx1 + 96*cx1*cx2 - 96*cy0*cy0 + 288*cy0*cy1 - 96*cy0*cy2 - 192*cy1*cy1 + 96*cy1*cy2,
    240*cx0*cx0 - 960*cx0*cx1 + 576*cx0*cx2 - 96*cx0*cx3 + 864*cx1*cx1 - 864*cx1*cx2 + 96*cx1*cx3 + 144*cx2*cx2 + 240*cy0*cy0 - 960*cy0*cy1 + 576*cy0*cy2 - 96*cy0*cy3 + 864*cy1*cy1 - 864*cy1*cy2 + 96*cy1*cy3 + 144*cy2*cy2,
    -320*cx0*cx0 + 1600*cx0*cx1 - 1344*cx0*cx2 + 416*cx0*cx3 - 32*cx0*cx4 - 1856*cx1*cx1 + 2784*cx1*cx2 - 704*cx1*cx3 + 32*cx1*cx4 - 864*cx2*cx2 + 288*cx2*cx3 - 320*cy0*cy0 + 1600*cy0*cy1 - 1344*cy0*cy2 + 416*cy0*cy3 - 32*cy0*cy4 - 1856*cy1*cy1 + 2784*cy1*cy2 - 704*cy1*cy3 + 32*cy1*cy4 - 864*cy2*cy2 + 288*cy2*cy3,
    240*cx0*cx0 - 1440*cx0*cx1 + 1536*cx0*cx2 - 672*cx0*cx3 + 96*cx0*cx4 + 2064*cx1*cx1 - 4128*cx1*cx2 + 1632*cx1*cx3 - 192*cx1*cx4 + 1872*cx2*cx2 - 1248*cx2*cx3 + 96*cx2*cx4 + 144*cx3*cx3 + 240*cy0*cy0 - 1440*cy0*cy1 + 1536*cy0*cy2 - 672*cy0*cy3 + 96*cy0*cy4 + 2064*cy1*cy1 - 4128*cy1*cy2 + 1632*cy1*cy3 - 192*cy1*cy4 + 1872*cy2*cy2 - 1248*cy2*cy3 + 96*cy2*cy4 + 144*cy3*cy3,
    -96*cx0*cx0 + 672*cx0*cx1 - 864*cx0*cx2 + 480*cx0*cx3 - 96*cx0*cx4 - 1152*cx1*cx1 + 2880*cx1*cx2 - 1536*cx1*cx3 + 288*cx1*cx4 - 1728*cx2*cx2 + 1728*cx2*cx3 - 288*cx2*cx4 - 384*cx3*cx3 + 96*cx3*cx4 - 96*cy0*cy0 + 672*cy0*cy1 - 864*cy0*cy2 + 480*cy0*cy3 - 96*cy0*cy4 - 1152*cy1*cy1 + 2880*cy1*cy2 - 1536*cy1*cy3 + 288*cy1*cy4 - 1728*cy2*cy2 + 1728*cy2*cy3 - 288*cy2*cy4 - 384*cy3*cy3 + 96*cy3*cy4,
    16*cx0*cx0 - 128*cx0*cx1 + 192*cx0*cx2 - 128*cx0*cx3 + 32*cx0*cx4 + 256*cx1*cx1 - 768*cx1*cx2 + 512*cx1*cx3 - 128*cx1*cx4 + 576*cx2*cx2 - 768*cx2*cx3 + 192*cx2*cx4 + 256*cx3*cx3 - 128*cx3*cx4 + 16*cx4*cx4 + 16*cy0*cy0 - 128*cy0*cy1 + 192*cy0*cy2 - 128*cy0*cy3 + 32*cy0*cy4 + 256*cy1*cy1 - 768*cy1*cy2 + 512*cy1*cy3 - 128*cy1*cy4 + 576*cy2*cy2 - 768*cy2*cy3 + 192*cy2*cy4 + 256*cy3*cy3 - 128*cy3*cy4 + 16*cy4*cy4
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> compute_Bezier_degree_5_singularities(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3, Scalar cx4, Scalar cy4, Scalar cx5, Scalar cy5,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    PolynomialRootFinder<Scalar, 8>::find_real_roots_in_interval({
        25*cx0*cx0 - 50*cx0*cx1 + 25*cx1*cx1 + 25*cy0*cy0 - 50*cy0*cy1 + 25*cy1*cy1,
    -200*cx0*cx0 + 600*cx0*cx1 - 200*cx0*cx2 - 400*cx1*cx1 + 200*cx1*cx2 - 200*cy0*cy0 + 600*cy0*cy1 - 200*cy0*cy2 - 400*cy1*cy1 + 200*cy1*cy2,
    700*cx0*cx0 - 2800*cx0*cx1 + 1700*cx0*cx2 - 300*cx0*cx3 + 2500*cx1*cx1 - 2500*cx1*cx2 + 300*cx1*cx3 + 400*cx2*cx2 + 700*cy0*cy0 - 2800*cy0*cy1 + 1700*cy0*cy2 - 300*cy0*cy3 + 2500*cy1*cy1 - 2500*cy1*cy2 + 300*cy1*cy3 + 400*cy2*cy2,
    -1400*cx0*cx0 + 7000*cx0*cx1 - 6000*cx0*cx2 + 2000*cx0*cx3 - 200*cx0*cx4 - 8000*cx1*cx1 + 12000*cx1*cx2 - 3200*cx1*cx3 + 200*cx1*cx4 - 3600*cx2*cx2 + 1200*cx2*cx3 - 1400*cy0*cy0 + 7000*cy0*cy1 - 6000*cy0*cy2 + 2000*cy0*cy3 - 200*cy0*cy4 - 8000*cy1*cy1 + 12000*cy1*cy2 - 3200*cy1*cy3 + 200*cy1*cy4 - 3600*cy2*cy2 + 1200*cy2*cy3,
    1750*cx0*cx0 - 10500*cx0*cx1 + 11500*cx0*cx2 - 5500*cx0*cx3 + 1050*cx0*cx4 - 50*cx0*cx5 + 14750*cx1*cx1 - 29500*cx1*cx2 + 12300*cx1*cx3 - 1850*cx1*cx4 + 50*cx1*cx5 + 12900*cx2*cx2 - 8600*cx2*cx3 + 800*cx2*cx4 + 900*cx3*cx3 + 1750*cy0*cy0 - 10500*cy0*cy1 + 11500*cy0*cy2 - 5500*cy0*cy3 + 1050*cy0*cy4 - 50*cy0*cy5 + 14750*cy1*cy1 - 29500*cy1*cy2 + 12300*cy1*cy3 - 1850*cy1*cy4 + 50*cy1*cy5 + 12900*cy2*cy2 - 8600*cy2*cy3 + 800*cy2*cy4 + 900*cy3*cy3,
    -1400*cx0*cx0 + 9800*cx0*cx1 - 13000*cx0*cx2 + 8000*cx0*cx3 - 2200*cx0*cx4 + 200*cx0*cx5 - 16400*cx1*cx1 + 41000*cx1*cx2 - 23200*cx1*cx3 + 5600*cx1*cx4 - 400*cx1*cx5 - 23600*cx2*cx2 + 23600*cx2*cx3 - 4600*cx2*cx4 + 200*cx2*cx5 - 4800*cx3*cx3 + 1200*cx3*cx4 - 1400*cy0*cy0 + 9800*cy0*cy1 - 13000*cy0*cy2 + 8000*cy0*cy3 - 2200*cy0*cy4 + 200*cy0*cy5 - 16400*cy1*cy1 + 41000*cy1*cy2 - 23200*cy1*cy3 + 5600*cy1*cy4 - 400*cy1*cy5 - 23600*cy2*cy2 + 23600*cy2*cy3 - 4600*cy2*cy4 + 200*cy2*cy5 - 4800*cy3*cy3 + 1200*cy3*cy4,
    700*cx0*cx0 - 5600*cx0*cx1 + 8700*cx0*cx2 - 6500*cx0*cx3 + 2300*cx0*cx4 - 300*cx0*cx5 + 10900*cx1*cx1 - 32700*cx1*cx2 + 23300*cx1*cx3 - 7700*cx1*cx4 + 900*cx1*cx5 + 23400*cx2*cx2 - 31200*cx2*cx3 + 9300*cx2*cx4 - 900*cx2*cx5 + 9400*cx3*cx3 - 4700*cx3*cx4 + 300*cx3*cx5 + 400*cx4*cx4 + 700*cy0*cy0 - 5600*cy0*cy1 + 8700*cy0*cy2 - 6500*cy0*cy3 + 2300*cy0*cy4 - 300*cy0*cy5 + 10900*cy1*cy1 - 32700*cy1*cy2 + 23300*cy1*cy3 - 7700*cy1*cy4 + 900*cy1*cy5 + 23400*cy2*cy2 - 31200*cy2*cy3 + 9300*cy2*cy4 - 900*cy2*cy5 + 9400*cy3*cy3 - 4700*cy3*cy4 + 300*cy3*cy5 + 400*cy4*cy4,
    -200*cx0*cx0 + 1800*cx0*cx1 - 3200*cx0*cx2 + 2800*cx0*cx3 - 1200*cx0*cx4 + 200*cx0*cx5 - 4000*cx1*cx1 + 14000*cx1*cx2 - 12000*cx1*cx3 + 5000*cx1*cx4 - 800*cx1*cx5 - 12000*cx2*cx2 + 20000*cx2*cx3 - 8000*cx2*cx4 + 1200*cx2*cx5 - 8000*cx3*cx3 + 6000*cx3*cx4 - 800*cx3*cx5 - 1000*cx4*cx4 + 200*cx4*cx5 - 200*cy0*cy0 + 1800*cy0*cy1 - 3200*cy0*cy2 + 2800*cy0*cy3 - 1200*cy0*cy4 + 200*cy0*cy5 - 4000*cy1*cy1 + 14000*cy1*cy2 - 12000*cy1*cy3 + 5000*cy1*cy4 - 800*cy1*cy5 - 12000*cy2*cy2 + 20000*cy2*cy3 - 8000*cy2*cy4 + 1200*cy2*cy5 - 8000*cy3*cy3 + 6000*cy3*cy4 - 800*cy3*cy5 - 1000*cy4*cy4 + 200*cy4*cy5,
    25*cx0*cx0 - 250*cx0*cx1 + 500*cx0*cx2 - 500*cx0*cx3 + 250*cx0*cx4 - 50*cx0*cx5 + 625*cx1*cx1 - 2500*cx1*cx2 + 2500*cx1*cx3 - 1250*cx1*cx4 + 250*cx1*cx5 + 2500*cx2*cx2 - 5000*cx2*cx3 + 2500*cx2*cx4 - 500*cx2*cx5 + 2500*cx3*cx3 - 2500*cx3*cx4 + 500*cx3*cx5 + 625*cx4*cx4 - 250*cx4*cx5 + 25*cx5*cx5 + 25*cy0*cy0 - 250*cy0*cy1 + 500*cy0*cy2 - 500*cy0*cy3 + 250*cy0*cy4 - 50*cy0*cy5 + 625*cy1*cy1 - 2500*cy1*cy2 + 2500*cy1*cy3 - 1250*cy1*cy4 + 250*cy1*cy5 + 2500*cy2*cy2 - 5000*cy2*cy3 + 2500*cy2*cy4 - 500*cy2*cy5 + 2500*cy3*cy3 - 2500*cy3*cy4 + 500*cy3*cy5 + 625*cy4*cy4 - 250*cy4*cy5 + 25*cy5*cy5
    },
    result, t0, t1, tol);

    return result;
}


template<typename Scalar>
std::vector<Scalar> compute_Bezier_degree_6_singularities(
        Scalar cx0, Scalar cy0, Scalar cx1, Scalar cy1, Scalar cx2, Scalar cy2, Scalar cx3, Scalar cy3, Scalar cx4, Scalar cy4, Scalar cx5, Scalar cy5, Scalar cx6, Scalar cy6,
        Scalar t0 = 0,
        Scalar t1 = 1) {
    std::vector<Scalar> result;
    constexpr Scalar tol = static_cast<Scalar>(1e-8);

    PolynomialRootFinder<Scalar, 10>::find_real_roots_in_interval({
        36*cx0*cx0 - 72*cx0*cx1 + 36*cx1*cx1 + 36*cy0*cy0 - 72*cy0*cy1 + 36*cy1*cy1,
    -360*cx0*cx0 + 1080*cx0*cx1 - 360*cx0*cx2 - 720*cx1*cx1 + 360*cx1*cx2 - 360*cy0*cy0 + 1080*cy0*cy1 - 360*cy0*cy2 - 720*cy1*cy1 + 360*cy1*cy2,
    1620*cx0*cx0 - 6480*cx0*cx1 + 3960*cx0*cx2 - 720*cx0*cx3 + 5760*cx1*cx1 - 5760*cx1*cx2 + 720*cx1*cx3 + 900*cx2*cx2 + 1620*cy0*cy0 - 6480*cy0*cy1 + 3960*cy0*cy2 - 720*cy0*cy3 + 5760*cy1*cy1 - 5760*cy1*cy2 + 720*cy1*cy3 + 900*cy2*cy2,
    -4320*cx0*cx0 + 21600*cx0*cx1 - 18720*cx0*cx2 + 6480*cx0*cx3 - 720*cx0*cx4 - 24480*cx1*cx1 + 36720*cx1*cx2 - 10080*cx1*cx3 + 720*cx1*cx4 - 10800*cx2*cx2 + 3600*cx2*cx3 - 4320*cy0*cy0 + 21600*cy0*cy1 - 18720*cy0*cy2 + 6480*cy0*cy3 - 720*cy0*cy4 - 24480*cy1*cy1 + 36720*cy1*cy2 - 10080*cy1*cy3 + 720*cy1*cy4 - 10800*cy2*cy2 + 3600*cy2*cy3,
    7560*cx0*cx0 - 45360*cx0*cx1 + 50400*cx0*cx2 - 25200*cx0*cx3 + 5400*cx0*cx4 - 360*cx0*cx5 + 63000*cx1*cx1 - 126000*cx1*cx2 + 54000*cx1*cx3 - 9000*cx1*cx4 + 360*cx1*cx5 + 54000*cx2*cx2 - 36000*cx2*cx3 + 3600*cx2*cx4 + 3600*cx3*cx3 + 7560*cy0*cy0 - 45360*cy0*cy1 + 50400*cy0*cy2 - 25200*cy0*cy3 + 5400*cy0*cy4 - 360*cy0*cy5 + 63000*cy1*cy1 - 126000*cy1*cy2 + 54000*cy1*cy3 - 9000*cy1*cy4 + 360*cy1*cy5 + 54000*cy2*cy2 - 36000*cy2*cy3 + 3600*cy2*cy4 + 3600*cy3*cy3,
    -9072*cx0*cx0 + 63504*cx0*cx1 - 85680*cx0*cx2 + 55440*cx0*cx3 - 17280*cx0*cx4 + 2232*cx0*cx5 - 72*cx0*cx6 - 104832*cx1*cx1 + 262080*cx1*cx2 - 152640*cx1*cx3 + 40680*cx1*cx4 - 4032*cx1*cx5 + 72*cx1*cx6 - 147600*cx2*cx2 + 147600*cx2*cx3 - 30600*cx2*cx4 + 1800*cx2*cx5 - 28800*cx3*cx3 + 7200*cx3*cx4 - 9072*cy0*cy0 + 63504*cy0*cy1 - 85680*cy0*cy2 + 55440*cy0*cy3 - 17280*cy0*cy4 + 2232*cy0*cy5 - 72*cy0*cy6 - 104832*cy1*cy1 + 262080*cy1*cy2 - 152640*cy1*cy3 + 40680*cy1*cy4 - 4032*cy1*cy5 + 72*cy1*cy6 - 147600*cy2*cy2 + 147600*cy2*cy3 - 30600*cy2*cy4 + 1800*cy2*cy5 - 28800*cy3*cy3 + 7200*cy3*cy4,
    7560*cx0*cx0 - 60480*cx0*cx1 + 95760*cx0*cx2 - 75600*cx0*cx3 + 30600*cx0*cx4 - 5760*cx0*cx5 + 360*cx0*cx6 + 115920*cx1*cx1 - 347760*cx1*cx2 + 255600*cx1*cx3 - 93600*cx1*cx4 + 15120*cx1*cx5 - 720*cx1*cx6 + 243000*cx2*cx2 - 324000*cx2*cx3 + 102600*cx2*cx4 - 12960*cx2*cx5 + 360*cx2*cx6 + 93600*cx3*cx3 - 46800*cx3*cx4 + 3600*cx3*cx5 + 3600*cx4*cx4 + 7560*cy0*cy0 - 60480*cy0*cy1 + 95760*cy0*cy2 - 75600*cy0*cy3 + 30600*cy0*cy4 - 5760*cy0*cy5 + 360*cy0*cy6 + 115920*cy1*cy1 - 347760*cy1*cy2 + 255600*cy1*cy3 - 93600*cy1*cy4 + 15120*cy1*cy5 - 720*cy1*cy6 + 243000*cy2*cy2 - 324000*cy2*cy3 + 102600*cy2*cy4 - 12960*cy2*cy5 + 360*cy2*cy6 + 93600*cy3*cy3 - 46800*cy3*cy4 + 3600*cy3*cy5 + 3600*cy4*cy4,
    -4320*cx0*cx0 + 38880*cx0*cx1 - 70560*cx0*cx2 + 65520*cx0*cx3 - 32400*cx0*cx4 + 7920*cx0*cx5 - 720*cx0*cx6 - 84960*cx1*cx1 + 297360*cx1*cx2 - 263520*cx1*cx3 + 122400*cx1*cx4 - 27360*cx1*cx5 + 2160*cx1*cx6 - 248400*cx2*cx2 + 414000*cx2*cx3 - 176400*cx2*cx4 + 34560*cx2*cx5 - 2160*cx2*cx6 - 158400*cx3*cx3 + 118800*cx3*cx4 - 18720*cx3*cx5 + 720*cx3*cx6 - 18000*cx4*cx4 + 3600*cx4*cx5 - 4320*cy0*cy0 + 38880*cy0*cy1 - 70560*cy0*cy2 + 65520*cy0*cy3 - 32400*cy0*cy4 + 7920*cy0*cy5 - 720*cy0*cy6 - 84960*cy1*cy1 + 297360*cy1*cy2 - 263520*cy1*cy3 + 122400*cy1*cy4 - 27360*cy1*cy5 + 2160*cy1*cy6 - 248400*cy2*cy2 + 414000*cy2*cy3 - 176400*cy2*cy4 + 34560*cy2*cy5 - 2160*cy2*cy6 - 158400*cy3*cy3 + 118800*cy3*cy4 - 18720*cy3*cy5 + 720*cy3*cy6 - 18000*cy4*cy4 + 3600*cy4*cy5,
    1620*cx0*cx0 - 16200*cx0*cx1 + 33120*cx0*cx2 - 35280*cx0*cx3 + 20520*cx0*cx4 - 6120*cx0*cx5 + 720*cx0*cx6 + 39780*cx1*cx1 - 159120*cx1*cx2 + 164880*cx1*cx3 - 92520*cx1*cx4 + 26280*cx1*cx5 - 2880*cx1*cx6 + 154800*cx2*cx2 - 309600*cx2*cx3 + 165600*cx2*cx4 - 43920*cx2*cx5 + 4320*cx2*cx6 + 147600*cx3*cx3 - 147600*cx3*cx4 + 35280*cx3*cx5 - 2880*cx3*cx6 + 33300*cx4*cx4 - 13320*cx4*cx5 + 720*cx4*cx6 + 900*cx5*cx5 + 1620*cy0*cy0 - 16200*cy0*cy1 + 33120*cy0*cy2 - 35280*cy0*cy3 + 20520*cy0*cy4 - 6120*cy0*cy5 + 720*cy0*cy6 + 39780*cy1*cy1 - 159120*cy1*cy2 + 164880*cy1*cy3 - 92520*cy1*cy4 + 26280*cy1*cy5 - 2880*cy1*cy6 + 154800*cy2*cy2 - 309600*cy2*cy3 + 165600*cy2*cy4 - 43920*cy2*cy5 + 4320*cy2*cy6 + 147600*cy3*cy3 - 147600*cy3*cy4 + 35280*cy3*cy5 - 2880*cy3*cy6 + 33300*cy4*cy4 - 13320*cy4*cy5 + 720*cy4*cy6 + 900*cy5*cy5,
    -360*cx0*cx0 + 3960*cx0*cx1 - 9000*cx0*cx2 + 10800*cx0*cx3 - 7200*cx0*cx4 + 2520*cx0*cx5 - 360*cx0*cx6 - 10800*cx1*cx1 + 48600*cx1*cx2 - 57600*cx1*cx3 + 37800*cx1*cx4 - 12960*cx1*cx5 + 1800*cx1*cx6 - 54000*cx2*cx2 + 126000*cx2*cx3 - 81000*cx2*cx4 + 27000*cx2*cx5 - 3600*cx2*cx6 - 72000*cx3*cx3 + 90000*cx3*cx4 - 28800*cx3*cx5 + 3600*cx3*cx6 - 27000*cx4*cx4 + 16200*cx4*cx5 - 1800*cx4*cx6 - 2160*cx5*cx5 + 360*cx5*cx6 - 360*cy0*cy0 + 3960*cy0*cy1 - 9000*cy0*cy2 + 10800*cy0*cy3 - 7200*cy0*cy4 + 2520*cy0*cy5 - 360*cy0*cy6 - 10800*cy1*cy1 + 48600*cy1*cy2 - 57600*cy1*cy3 + 37800*cy1*cy4 - 12960*cy1*cy5 + 1800*cy1*cy6 - 54000*cy2*cy2 + 126000*cy2*cy3 - 81000*cy2*cy4 + 27000*cy2*cy5 - 3600*cy2*cy6 - 72000*cy3*cy3 + 90000*cy3*cy4 - 28800*cy3*cy5 + 3600*cy3*cy6 - 27000*cy4*cy4 + 16200*cy4*cy5 - 1800*cy4*cy6 - 2160*cy5*cy5 + 360*cy5*cy6,
    36*cx0*cx0 - 432*cx0*cx1 + 1080*cx0*cx2 - 1440*cx0*cx3 + 1080*cx0*cx4 - 432*cx0*cx5 + 72*cx0*cx6 + 1296*cx1*cx1 - 6480*cx1*cx2 + 8640*cx1*cx3 - 6480*cx1*cx4 + 2592*cx1*cx5 - 432*cx1*cx6 + 8100*cx2*cx2 - 21600*cx2*cx3 + 16200*cx2*cx4 - 6480*cx2*cx5 + 1080*cx2*cx6 + 14400*cx3*cx3 - 21600*cx3*cx4 + 8640*cx3*cx5 - 1440*cx3*cx6 + 8100*cx4*cx4 - 6480*cx4*cx5 + 1080*cx4*cx6 + 1296*cx5*cx5 - 432*cx5*cx6 + 36*cx6*cx6 + 36*cy0*cy0 - 432*cy0*cy1 + 1080*cy0*cy2 - 1440*cy0*cy3 + 1080*cy0*cy4 - 432*cy0*cy5 + 72*cy0*cy6 + 1296*cy1*cy1 - 6480*cy1*cy2 + 8640*cy1*cy3 - 6480*cy1*cy4 + 2592*cy1*cy5 - 432*cy1*cy6 + 8100*cy2*cy2 - 21600*cy2*cy3 + 16200*cy2*cy4 - 6480*cy2*cy5 + 1080*cy2*cy6 + 14400*cy3*cy3 - 21600*cy3*cy4 + 8640*cy3*cy5 - 1440*cy3*cy6 + 8100*cy4*cy4 - 6480*cy4*cy5 + 1080*cy4*cy6 + 1296*cy5*cy5 - 432*cy5*cy6 + 36*cy6*cy6
    },
    result, t0, t1, tol);

    return result;
}


template<typename Derived>
std::vector<typename Derived::Scalar> compute_Bezier_singularities(
        const Eigen::PlainObjectBase<Derived>& ctrl_pts,
        typename Derived::Scalar t0 = 0,
        typename Derived::Scalar t1 = 1) {
    switch(ctrl_pts.rows()-1) {
        case 2:
            return compute_Bezier_degree_2_singularities(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), t0, t1);
        case 3:
            return compute_Bezier_degree_3_singularities(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), t0, t1);
        case 4:
            return compute_Bezier_degree_4_singularities(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), ctrl_pts(4,0), ctrl_pts(4,1), t0, t1);
        #ifdef HIGH_DEGREE_SUPPORT
        case 5:
            return compute_Bezier_degree_5_singularities(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), ctrl_pts(4,0), ctrl_pts(4,1), ctrl_pts(5,0), ctrl_pts(5,1), t0, t1);
        #endif // HIGH_DEGREE_SUPPORT
        #ifdef HIGH_DEGREE_SUPPORT
        case 6:
            return compute_Bezier_degree_6_singularities(ctrl_pts(0,0), ctrl_pts(0,1), ctrl_pts(1,0), ctrl_pts(1,1), ctrl_pts(2,0), ctrl_pts(2,1), ctrl_pts(3,0), ctrl_pts(3,1), ctrl_pts(4,0), ctrl_pts(4,1), ctrl_pts(5,0), ctrl_pts(5,1), ctrl_pts(6,0), ctrl_pts(6,1), t0, t1);
        #endif // HIGH_DEGREE_SUPPORT
        default:
            throw not_implemented_error(
                "Singularity computation only works on Bezier curve with degree lower than 6");
    }
}



} // End internal namespace
} // End nanospline namespace

