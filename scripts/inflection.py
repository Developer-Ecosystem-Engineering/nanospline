#!/usr/bin/env python
# coding=utf-8
import os
from sympy import *
from scipy.special import comb
import numpy as np
from sympy.printing.ccode import C99CodePrinter


code_template_heder = """
// This code is automatically generated by scripts/inflection.py

#pragma once
#include <cassert>
#include <vector>

#include <nanospline/Exceptions.h>
#include <nanospline/PolynomialRootFinder.h>
#include <nanospline/Bezier.h>
#include <nanospline/RationalBezier.h>

namespace nanospline {

"""

code_template = """
template<typename Scalar, int _degree=3, bool generic=_degree<0 >
std::vector<Scalar> compute_inflections(
        const {type}<Scalar, 2, _degree, generic>& curve,
        Scalar t0 = 0, Scalar t1 = 1) {{
    std::vector<Scalar> result;
    constexpr Scalar tol = 1e-8;

{body}

    return result;
}}
"""

code_template_footer = """
}

"""


def bezier(degree, t, rational, sysms):
    tot = 0
    n = degree

    denom = 0
    for i in range(n+1):
        if rational:
            tot += int(comb(n, i)) * (1-t)**(n-i) * t**i * syms[i][0] * syms[i][1]
        else:
            tot += int(comb(n, i)) * (1-t)**(n-i) * t**i * syms[i][0]
        denom += int(comb(n, i)) * (1-t)**(n-i) * t**i * syms[i][1]

    if rational:
        return tot/denom

    return tot


def setup_functions():
    functions = {}

    beziers = []

    for i in range(2, 11):
        beziers.append((i+1, i, False, lambda t, syms, i=i: bezier(i, t, False, syms)))

    functions["Bezier"] = beziers

    rbeziers = []

    for i in range(2, 5):
        rbeziers.append((i+1, i, True, lambda t, syms, i=i: bezier(i, t, True, syms)))

    functions["RationalBezier"] = rbeziers

    return functions


def create_coeff_symbols(n_coeffs):
    syms = []

    for i in range(n_coeffs):
        syms.append((
            np.array([
            symbols('cx{}'.format(i)),
            symbols('cy{}'.format(i))]),
            symbols('w{}'.format(i))))

    return syms


def generate_solver_code(n_coeffs, coeffs, is_rational, printer):
    lines = []
    lines.append("const auto& ctrl_pts = curve.get_control_points();")

    if is_rational:
        lines.append("const auto& weights = curve.get_weights();")

    for i in range(n_coeffs):
        lines.append("Scalar cx{0} = ctrl_pts({0}, 0);".format(i))
        lines.append("Scalar cy{0} = ctrl_pts({0}, 1);".format(i))
        if is_rational:
            lines.append("Scalar w{0} = weights({0});".format(i))

    lines.append("PolynomialRootFinder<Scalar, {}>::find_real_roots_in_interval({{".format(poly.degree()))

    lines.append(",\n".join(
        ["    {}".format(printer.doprint(c)) for c in coeffs]))
    lines.append("},")
    lines.append("result, t0, t1, tol);")

    return lines

if __name__ == "__main__":
    functions = setup_functions()
    t = symbols('t')

    printer = C99CodePrinter()
    code = code_template_heder

    for poly_name in functions:
        lines = []
        first=True
        for n_coeffs, degree, is_rational, curve in functions[poly_name]:
            syms = create_coeff_symbols(n_coeffs)
            func = curve(t, syms)

            tx = (diff(func[0], t))
            ty = (diff(func[1], t))

            nx = -(diff(func[1], t, 2))
            ny = (diff(func[0], t, 2))

            eq = together(tx*nx+ty*ny)
            n, _ = fraction(eq)

            poly = Poly(n, t)
            coeffs = poly.all_coeffs()
            coeffs.reverse()

            lines.append("{}if (curve.get_degree() == {}) {{".format(
                "" if first else "} else ", degree))
            first = False

            solver_lines = generate_solver_code(n_coeffs, coeffs, is_rational, printer)
            for l in solver_lines:
                lines.append("    " + l)

        lines.append("} else{")
        lines.append("    throw not_implemented_error(")
        lines.append("        \"Inflection computation only works on {} curve with degree lower than {}\");".format(poly_name, degree))
        lines.append("}")

        body = "\n".join(["    {}".format(l) for l in lines])
        code += code_template.format(type=poly_name, body=body) + "\n\n"

    code += code_template_footer
    dir_path = os.path.dirname(os.path.realpath(__file__))
    with open(os.path.join(dir_path, "..", "include", "nanospline", "inflection.h"), "w") as f:
        f.write(code)
